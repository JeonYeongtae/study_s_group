# 데이터베이스 설계

효율적으로 테이블을 설계하고 관리하는 방법을 알아보자.

---

## ✅ ER 다이어그램

> 엔티티 관계를 표현하는 ER 다이어그램 (ERD)

---

### 📌 목적

- 데이터베이스에 저장되는 엔티티의 구조를 모델링하는 것
- 데이터베이스로 표현할 대상을 시각적으로 설계하는 것

데이터베이스 설계 초기 단계에서 중요한 역할을 한다!

→ ERD를 활용해 데이터베이스의 구조를 명확하게 정의해두면, 추후에 데이터베이스를 확장하거나 수정할 때 어떤 부분이 영향을 받는지 쉽게 파악할 수 있어서 유지보수가 용이하고 개발자 간 원활한 소통이 가능하다.

---

### 📌 ERD는 어떻게 생겼나?

```scss
 ╔════════════╗                 ╔════════════╗
 ║  Employee  ║ -----0..1-----> ║   Office   ║
 ╚════════════╝                 ╚════════════╝
    id (PK)                        id (PK)
    name                           name
    office_id (FK, nullable)

 관계: 0개 또는 1개 (0..1)
 설명: 직원은 사무실이 없거나 하나만 가질 수 있음

 ╔════════════╗                 ╔════════════╗
 ║  Resident  ║ =====1:1=====>  ║   IDCard   ║
 ╚════════════╝                 ╚════════════╝
    id (PK)                        id (PK)
    name                           resident_id (FK, UNIQUE, NOT NULL)

 관계: 정확히 1개 (1:1)
 설명: 주민은 반드시 하나의 주민등록증을 가짐 (양방향 1:1)

 ╔════════════╗                 ╔════════════╗
 ║  Customer  ║ -----0..N-----> ║    Order   ║
 ╚════════════╝                 ╚════════════╝
    id (PK)                        id (PK)
    name                           customer_id (FK)

 관계: 0개 또는 여러 개 (0..N)
 설명: 고객은 주문을 하지 않을 수도 있고 여러 개 할 수도 있음

 ╔════════════╗     ╔══════════════╗     ╔════════════╗
 ║    Post    ║<--1 ║    PostTag   ║ N-->║    Tag     ║
 ╚════════════╝     ╚══════════════╝     ╚════════════╝
    id (PK)            post_id (FK)         id (PK)
    title              tag_id  (FK)         name

 관계: 다대다 (N:M)
 설명: 글은 하나 이상의 태그를 가져야 하고, 태그도 여러 글에 연결됨
       PostTag 중간 테이블로 다대다 관계를 표현
```

- 식별/비식별 관계
  - 식별 관계: 참조되는 엔티티가 존재해야만 참조하는 엔티티가 존재할 수 있는 관계 (실선)
  - 비식별 관계: 참조되는 엔티티가 존재하지 않아도 참조하는 엔티티가 존재할 수 있는 관계 (점선)

---

## ✅ 정규화

> 정규화된 테이블의 형태 (Normal Form, NF)

### 📌 제 1 정규형

> 모든 속성이 원자 값을 가진다.
> 필드 데이터가 더 이상 쪼개질 수 없는 값을 가져야 한다.

### 📌 제 2 정규형

> 제 1 정규형을 만족함과 동시에, 기본 키가 아닌 모든 필드들이 모든 기본 키에 완전히 종속된다.
> 기본 키의 일부에만 종속되는 필드가 있다면, 이를 제거하여 기본 키 전체에 종속되도록 필드를 구성해야 한다.

- 부분 함수 종속성: 기본 키가 아닌 필드가 기본 키의 일부에 종속되어 있는 경우
- 완전 함수 종속성: 기본 키 전체에 완전하게 종속되어 있는 경우

→ 제 2 정규형은 부분 함수 종속성이 없는 상태, 완전 함수 종속인 상태이다.

### 📌 제 3 정규형

> 제 2 정규형을 만족하면서, 기본 키가 아닌 모든 필드가 기본 키에 이행적 종속성이 없는 상태

- 이행적 종속 관계: 어떤 테이블에 A, B, C라는 필드가 있을 때, A가 B를 결정하고 B가 C를 결정한다면, A도 C를 결정하게 되어 종속 관계를 형성

→ 기본 키가 아닌 나머지 모든 필드들이 간접적으로라도 종속되어서는 안 된다, 기본 키가 아닌 나머지 모든 필드는 서로 유추하거나 결정할 수 없어야 한다.

### 📌 보이스/코드 정규형

> 제 3 정규형을 만족하는 동시에 모든 결정자가 후보 키여야 한다.

---

### 📌 역정규화 - 정규화가 무조건적인 미덕일까

> 검색의 속도를 높이기 위해 분할되어 있는 테이블을 하나로 합치는 작업

- 정규화를 거듭하다 보면 테이블이 쪼개지는 경향이 있는데, 이렇게 테이블이 많아지면 자연스럽게 조인 연산이 빈번해지고, 다른 테이블을 참조하기 위한 성능 상의 비용이 늘어날 수 있다.
- 정규화 단계를 거듭할수록 데이터는 깔끔하게 정돈되고, 데이터베이스 작업 시 이상 현상이 줄어드는 것은 맞지만, 이것이 오히려 성능을 저해할 수 있다.
  → 성능상의 이점을 최대한 활용하고자 할 때는 어느 정도의 데이터 중복과 삽입/수정/삭제 연산에서의 번거로움을 감수하고서라도 가급적 하나의 테이블로 데이터를 관리하기도 한다.

---

# NoSQL

> RDBMS와의 차이점을 중심으로 NoSQL의 주요 특징에 대해 알아보고,
> 다양한 NoSQL 유형의 데이터베이스가 데이터를 조회하고, 삽입/수정/삭제하는 예제를 살펴보자.

---

## ✅ RDBMS vs NoSQL: NoSQL의 특징

- 높은 부하를 감당하거나 대용량 데이터를 다루는 분산 환경에서 용이 (확장성, 유연성, 가용성, 성능때문에) → `용이한 스케일 아웃(수평적 확장`
- 대표적인 NoSQL 데이터베이스 유형으로는 `키-값 데이터베이스`, `도큐먼트 데이터베이스`, `그래프 데이터베이스`, `칼럼 패밀리 데이터베이스` 4가지를 꼽을 수 있다.
- NoSQL은 RDBMS를 완전히 대체할 수는 없다.
  - ACID에 대한 엄격한 준수나 데이터의 무결성, 일관성 유지가 중요한 환경에서는 RDBMS가 더 적합하다.
  - 데이터가 비교적 정형화되어 있거나 (스키마가 비교적 고정되어 있거나) 확장성을 크게 염두하고 있지 않다면 굳이 가용성에 중점을 두고 비정형화된 형태를 다루는 NoSQL을 사용할 필요는 없다.
  → 주어진 상황에 필요한 장단점에 따라 선택하는 것이 중요!!!

---

### 📌 키-값 데이터베이스

> 데이터베이스에 레코드를 키(필드)와 값의 쌍으로 저장하는 데이터베이스
> Redis, Memcached

- 인메모리 데이터베이스: 레코드를 보조기억장치가 아니라 메모리에 저장
- 캐시나 세션 등 비교적 가벼운 정보를 저장하는 경우가 많다.
- 다른 주요 데이터베이스의 보조 데이터베이스로도 사용된다.

### 📌 도큐먼트 데이터베이스

> 레코드를 도큐먼트라는 단위로 저장하고 관리하는 데이터베이스
> MongoDB

- 도큐먼트: 정형화되어 있지 않은 NoSQL 레코드의 단위
- MongoDB
  - 하나의 레코드를 JSON 형태의 데이터로 만들어 관리
  - RDBMS와는 달리 고정된 스키마가 없기 때문에 각 도큐먼트가 유연한 스키마를 가질 수 있다.
  - 도큐먼트가 모여 컬렉션을 이룬다

### 📌 그래프 데이터베이스

> 저장하고자 하는 데이터를 그래프의 노드 형태로 저장하는 데이터베이스

- 방향 그래프를 표현하기 위해 활용되며, 노드 간의 연결 관계와 방향을 표현할 수 있다.
- SNS의 친구 관계나 교통망처럼 데이터 간의 관계성이 중요한 레코드를 저장하기 위해 주로 사용

### 📌 칼럼 패밀리 데이터베이스

> RDBMS에서 키를 통해 특정 행을 식별하듯 로우 키를 통해 특정 행을 식별
> RDBMS와는 다르게 정규화나 조인을 사용하지 않고, 스키마가 고정되어 있지 않아 자유롭게 열을 추가할 수 있음 → 동적으로 변할 수 있는 열들이 있고, 거기에 행 데이터들이 대응되어 있는 것에 가깝다.

- 관련 있는 열들이 모여 `칼럼 패밀리` 라는 단위를 형성하고, 이 칼럼 패밀리는 `키스페이스` 라는 단위를 형성
- `키스페이스` : 여러 칼럼 패밀리들을 포괄하는 칼럼 패밀리 데이터베이스의 최상위 단위
  - 일반적으로, 애플리케이션마다 키스페이스가 하나씩 사용
  → 칼럼 패밀리 데이터베이스의 키스페이스는 여러 칼럼 패밀리를 포함할 수 있고, 칼럼 패밀리는 다시 여러 열을 포함할 수 있다.
  → 이 열들은 자유롭게 가감될 수 있기 때문에 RDBMS의 테이블보다 더 자유로운 형태로 레코드를 다룰 수 있다.

---

## ✨ 데이터베이스 분할과 샤딩

### 📌 데이터베이스 분할

- 일반적으로 데이터베이스에는 수많은 레코드들이 저장되며, DBMS는 모든 레코드들을 손실 없이 안전하게 저장해야 한다.
- 설령 테이블을 올바르게 설계했더라도 삽입되는 레코드가 점점 많아지고 테이블의 규모가 커지면 어쩔 수 없이 테이블을 로드하거나 질의하는 성능이 저해될 수 있다.
- 레코드가 많은 특정 테이블에 부하가 몰려 병목이 생길 수도 있다.

→ 이에 안정적이고 확장성 높은 데이터베이스 레코드 관리를 위해 테이블을 물리적으로 분할하여 레코드를 저장하는 기술이 등장 : `데이터베이스 분할` , `데이터베이스 파티셔닝`

- `수직적 분할`: 테이블의 열을 기준으로 테이블을 나누어 저장하는 방식
  - 동기
    - 테이블에 발생하는 트랜잭션 수에 비해 테이블 내에 열이 과도하게 많거나
    - 특정 열에 속하는 레코드의 데이터 크기가 다른 열의 레코드에 비해 과도하게 큰 경우
    - 보안 상의 이유로 특정 열을 별개의 테이블로 나누어 저장해야 하는 경우
- `수평적 분할`: 테이블의 행을 기준으로 테이블을 나누어 저장하는 방식
  - 동기
    - 테이블에 수많은 레코드가 존재하고, 테이블의 레코드를 참조할 때마다 모든 레코드를 한 번에 불러들일 필요가 없는 경우
  - 방법
    - 범위 분할
      > 레코드 데이터가 가질 수 있는 범위를 정의하고, 해당 범위를 기준으로 테이블을 나눈다.
    - 목록 분할
      > 레코드 데이터가 특정 목록(리스트)에 포함된 값을 가질 경우 해당 레코드를 별도의 테이블로 분할한다.
